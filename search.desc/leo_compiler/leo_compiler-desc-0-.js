searchState.loadedDescShard("leo_compiler", 0, "leo-compiler\nThe abstract syntax tree (AST) for a Leo program.\nThe primary entry point of the Leo compiler.\nReturns a reference to the inner program AST …\nThe <code>Assigner</code> is used to construct (unique) assignment …\nThe AST for the program.\nWhether spans are enabled in the output ASTs.\nAttach a finalize to a function.\nBuild options.\nRecursively checks if the symbol table contains an entry …\nThe compiler for Leo programs.\nOptions configuring compilation.\nMax depth to type check nested conditionals.\nIf enabled writes the AST after dead code elimination.\nWhether to enable dead code elimination.\nIf enabled writes the AST after destructuring.\nWhether to disable type checking for nested conditionals.\nIf enabled writes the AST after flattening.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDeserializes the JSON string into a symbol table from a …\nDeserializes the JSON string into a ast from a file.\nDeserializes the JSON string into a symbol table.\nDeserializes the JSON string into a ast.\nMaps parent program name and  function name to the AST’s …\nThe handler is used for error and warning emissions.\nThe stubs for imported programs. Produced by <code>Retriever</code> …\nIf enabled writes the AST after parsing.\nIf enabled writes the AST after inlining.\nCreates a new scope for the block and stores it in the …\nInserts a function into the symbol table.\nInserts futures into the function definition.\nInserts a struct into the symbol table.\nInserts a variable into the symbol table.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAttempts to lookup a function in the symbol table.\nReturns the scope associated with <code>index</code>, if it exists in …\nAttempts to lookup a struct in the symbol table.\nAttempts to lookup a variable in the symbol table.\nAttempts to lookup a variable in the current scope.\nThe path to the main leo file.\nThe network name,\nCreates a new AST from a given program tree.\nThe <code>NodeCounter</code> used to generate sequentially increasing …\nOutput options.\nThe path to where the compiler outputs all generated files.\nThe program name,\nRemoves a variable from the symbol table.\nReturns the current scope index. Increments the scope …\nIf enabled writes the AST after static single assignment.\nMaps parent program name and composite name to composite …\nSerializes the ast into a JSON file.\nSerializes the symbol table into a JSON value and removes …\nSerializes the ast into a JSON value and removes keys from …\nSerializes the symbol table into a JSON string.\nSerializes the ast into a JSON string.\nConverts the symbol table into a JSON value\nIf enabled writes the symbol table after type checking.\nThe type table.\nIf enabled writes the AST after loop unrolling.\nIf enabled writes the symbol table after loop unrolling.\nThe abstract syntax tree (AST) for a Leo program.\nThe primary entry point of the Leo compiler.\nMerges the dependencies defined in <code>program.json</code> with the …\nThe <code>Assigner</code> is used to construct (unique) assignment …\nThe AST for the program.\nReturns a SHA256 checksum of the program file.\nRuns the code generation pass.\nReturns a compiled Leo program.\nOptions configuring compilation.\nRuns the compiler stages.\nRuns the dead code elimination pass.\nRuns the destructuring pass.\nRuns the flattening pass.\nReturns the argument unchanged.\nRuns the function inlining pass.\nMaps parent program name and  function name to the AST’s …\nThe handler is used for error and warning emissions.\nThe stubs for imported programs. Produced by <code>Retriever</code> …\nCalls <code>U::from(self)</code>.\nRuns the loop unrolling pass.\nThe path to the main leo file.\nThe network name,\nReturns a new Leo compiler.\nThe <code>NodeCounter</code> used to generate sequentially increasing …\nThe path to where the compiler outputs all generated files.\nParses and stores the main program file, constructs a …\nParses and stores a program file content from a string, …\nThe program name,\nRuns the static analysis pass.\nRuns the static single assignment pass.\nMaps parent program name and composite name to composite …\nRuns the symbol table pass.\nRuns the type checker pass.\nThe type table.\nWrites the AST to a JSON file.\nWrites the Symbol Table to a JSON file.\nWhether spans are enabled in the output ASTs.\nBuild options.\nMax depth to type check nested conditionals.\nIf enabled writes the AST after dead code elimination.\nWhether to enable dead code elimination.\nIf enabled writes the AST after destructuring.\nWhether to disable type checking for nested conditionals.\nIf enabled writes the AST after flattening.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf enabled writes the AST after parsing.\nIf enabled writes the AST after inlining.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOutput options.\nIf enabled writes the AST after static single assignment.\nIf enabled writes the symbol table after type checking.\nIf enabled writes the AST after loop unrolling.\nIf enabled writes the symbol table after loop unrolling.")