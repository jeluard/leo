searchState.loadedDescShard("leo_passes", 0, "leo-passes\nThe Dead Code Elimination pass traverses the AST and …\nThe destructuring pass traverses the AST and destructures …\nThe flattening pass traverses the AST after the SSA pass …\nThe Function Inlining pass traverses the AST and inlines …\nThe Static Single Assignment pass traverses the AST and …\nThe call graph for the program.\nMapping of composite names to a tuple containing metadata …\nThe depth of the current conditional block.\nReference to the current function.\nA reference to the finalize caller.\nReturns the argument unchanged.\nMapping of global identifiers to their associated names.\nCalls <code>U::from(self)</code>.\nInitializes a new <code>CodeGenerator</code>.\nA counter to track the next available label.\nA counter to track the next available register.\nA reference to program. This is needed to look up external …\nThe program ID of the current program.\nThe struct dependency graph for the program.\nThe symbol table for the program.\nA mapping between expressions and their types.\nMapping of variables to registers.\nThe variant of the function we are currently traversing.\nA struct used to create assignment statements.\nContains the actual data for <code>Assigner</code>. Modeled this way to …\nA strictly increasing counter, used to ensure that new …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe inner counter. <code>RefCell</code> is used here to avoid <code>&amp;mut</code> all …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs the assignment statement <code>place = expr;</code>. This …\nConstructs the assignment statement <code>place = expr;</code>. This …\nReturn a new unique <code>Symbol</code> from a <code>&amp;str</code>.\nReturn a new unique <code>Symbol</code> from a <code>&amp;str</code>.\nReturns true if the constant exists in the local scope\nReturns true if the constant exists in any parent scope\nThe known constants in the current scope This field is …\nReturns the argument unchanged.\nCreates a new scope for the block and stores it in the …\nInserts a constant into the constant propagation table.\nCalls <code>U::from(self)</code>.\nAttempts to lookup a constant in the constant propagation …\nReturns the scope associated with <code>index</code>, if it exists in …\nThe parent scope if it exists. For example, the parent …\nReturns the current scope index. Increments the scope …\nThe index of the current scope.\nThe sub-scopes of this scope.\nA call graph.\nAn error that is emitted when a cycle is detected in the …\nA directed graph.\nErrors in directed graph operations.\nAn import dependency graph.\nA node in a graph.\nA struct dependency graph.\nAdds an edge to the graph.\nReturns <code>true</code> if the graph contains the given node.\nThe directed edges in the graph. Each entry in the map is …\nThe directed edges in the graph. Each entry in the map is …\nThe directed edges in the graph. Each entry in the map is …\nThe directed edges in the graph. Each entry in the map is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInitializes a new <code>DiGraph</code> from a vector of source nodes.\nThe set of nodes in the graph.\nThe set of nodes in the graph.\nThe set of nodes in the graph.\nThe set of nodes in the graph.\nReturns the post-order ordering of the graph. Detects if …\nRetains a subset of the nodes, and removes all edges in …\n<code>RenameTable</code> tracks the names assigned by static single …\nReturns the argument unchanged.\nThe mapping from symbols to node IDs. These are used to …\nCalls <code>U::from(self)</code>.\nReturns the symbols that were renamed in the current scope.\nLooks up the new name for <code>symbol</code>, recursively checking the …\nLooks up the node ID for <code>symbol</code>, recursively checking the …\nThe mapping from names in the original AST to new names in …\nCreate a new <code>RenameTable</code> with the given parent.\nThe <code>RenameTable</code> of the parent scope.\nUpdates <code>self.mapping</code> with the desired entry. Creates a new …\nA <code>Replacer</code> applies <code>replacer</code> to all <code>Identifier</code>s in an AST. …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAttach a finalize to a function.\nChecks if two structs are equal.\nRecursively checks if the symbol table contains an entry …\nReturns the argument unchanged.\nDeserializes the JSON string into a symbol table from a …\nDeserializes the JSON string into a symbol table.\nMaps parent program name and  function name to the AST’s …\nCreates a new scope for the block and stores it in the …\nInserts a function into the symbol table.\nInserts futures into the function definition.\nInserts a struct into the symbol table.\nInserts a variable into the symbol table.\nCalls <code>U::from(self)</code>.\nAttempts to lookup a function in the symbol table.\nReturns the scope associated with <code>index</code>, if it exists in …\nAttempts to lookup a struct in the symbol table.\nAttempts to lookup a variable in the symbol table.\nAttempts to lookup a variable in the current scope.\nThe parent scope if it exists. For example, the parent …\nRemoves a variable from the symbol table.\nReturns the current scope index. Increments the scope …\nThe index of the current scope.\nThe sub-scopes of this scope.\nMaps parent program name and composite name to composite …\nSerializes the symbol table into a JSON value and removes …\nSerializes the symbol table into a JSON string.\nConverts the symbol table into a JSON value\nThe variables defined in a scope. This field is populated …\nAn entry for a function in the symbol table.\nThe <code>Span</code> associated with the function.\nThe finalize block associated with the function.\nReturns the argument unchanged.\nFuture inputs.\nThe index associated with the scope in the parent symbol …\nThe inputs to the function.\nCalls <code>U::from(self)</code>.\nThe output type of the function.\nIs this function a transition, inlined, or a regular …\nAn entry for a variable in the symbol table.\nAn enumeration of the different types of variable type.\nThe type of declaration for the variable.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe <code>Span</code> associated with the variable.\nThe <code>Type</code> of the variable.\nA binary search tree to store all paths through nested …\nA node in a graph.\nA node in a tree.\nA counter.\nA counter.\nAdds a child to the current node.\nThe current depth.\nThe current depth.\nThe current node.\nThe current node.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInitializes a new <code>TreeNode</code> from a vector of starting …\nRemoves an element from the current node. If the element …\nA mapping between node IDs and their types.\nReturns the argument unchanged.\nGets an entry from the table.\nThe inner table. <code>RefCell</code> is used here to avoid <code>&amp;mut</code> all …\nInserts an entry into the table.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether or not we are currently traversing an async …\nWhether or not the variables are necessary.\nInitializes a new <code>DeadCodeEliminator</code>.\nA counter to generate unique node IDs.\nReconstruct an assignment statement by eliminating any …\nReconstructs the associated function access expression.\nReconstructs the statements inside a basic block, …\nFlattening removes conditional statements from the program.\nParsing guarantees that console statements are not present …\nStatic single assignment replaces definition statements …\nReconstructs expression statements by eliminating any dead …\nMarks identifiers as used. This is necessary to determine …\nLoop unrolling unrolls and removes iteration statements …\nReconstruct the components of the struct init expression. …\nThe set of used variables in the current function body.\nA struct used to construct (unique) assignment statements.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether or not we are currently traversing an async …\nA counter used to generate unique node IDs.\nFlattens an assign statement, if necessary. Marks …\nReconstructs\nReplaces a tuple access expression with the appropriate …\nA wrapper around <code>assigner.simple_assign_statement</code> that …\nA mapping between variables and flattened tuple …\nA mapping between node IDs and their types.\nA Constructed guard is one which as been <code>And</code>ed with all …\nThere was a chain of conditionals on the path to this …\nAn expression representing a conditional to reach the …\nThere were no conditionals on the path to this return …\nAn Unconstructed guard is one representing a single …\nThere was a chain of conditionals on the path to this …\nA struct used to construct (unique) assignment statements.\nA stack of condition <code>Expression</code>s visited up to the current …\nConstruct an early return guard.\nConstruct a guard from the current state of the condition …\nFold guards and expressions into a single expression. Note …\nFolds a list of return statements into a single return …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether the function is an async function.\nA counter used to generate unique node IDs.\nThe program name.\nRewrites an assert statement into a flattened form. Assert …\nFlattens an assign statement, if necessary. Marks …\nFlattens the statements inside a basic block. The …\nFlatten a conditional statement into a list of statements.\nFlattens a function’s body\nFlattens a program scope.\nTransforms a return statement into an empty block …\nReconstructs a struct init expression, flattening any …\nReconstructs ternary expressions over arrays, structs, and …\nA list containing tuples of guards and expressions …\nA wrapper around <code>assigner.simple_assign_statement</code> that …\nThe symbol table associated with the program.\nA mapping between node IDs and their types.\nA wrapper around <code>assigner.unique_simple_assign_statement</code> …\nTrue iff any of the guards to return statements so far …\nTrue iff the conditionals on the path to this return …\nAn <code>AssignmentRenamer</code> renames the left-hand side of all …\nClear the internal rename table.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLoad the internal rename table with a set of entries.\nInitialize a new <code>AssignmentRenamer</code>.\nRename the left-hand side of the assignment statement.\nFlattening removes conditional statements from the program.\nParsing guarantees that console statements are not present …\nStatic single assignment replaces definition statements …\nRename the identifier if it is the left-hand side of an …\nLoop unrolling unrolls and removes iteration statements …\nRename the variable initializers in the struct expression.\nA wrapper around an Assigner used to create unique …\nThe call graph for the program.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether or not we are currently traversing an async …\nInitializes a new <code>FunctionInliner</code>.\nA counter used to create unique NodeIDs.\nThe main program.\nReconstruct an assignment statement by inlining any …\nReconstructs the statements inside a basic block, …\nFlattening removes conditional statements from the program.\nParsing guarantees that console statements are not present …\nStatic single assignment replaces definition statements …\nReconstructs expression statements by inlining any …\nLoop unrolling unrolls and removes iteration statements …\nA map of reconstructed functions in the current program …\nA mapping between node IDs and their types.\nWhether or not a bound is inclusive or exclusive.\nA trait for whose implementors are concrete values for …\nAn iterator over a range of values.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA table of constant variables.\nThe current program name.\nReturns the index of the current scope. Note that if we …\nEmits a Loop Unrolling Error\nEnters a child scope.\nExits the current block scope.\nReturns the argument unchanged.\nAn error handler used for any errors found during …\nCalls <code>U::from(self)</code>.\nAre we in the midst of unrolling a loop?\nA counter used to generate unique node IDs.\nThe index of the current scope.\nThe symbol table for the function being processed.\nA mapping from node IDs to their types.\nUnrolls an IterationStatement.\nA helper function to unroll a single iteration an …\nA compiler pass consuming <code>Self::Input</code> and returning …\nRuns the compiler pass.\nType checks the awaiting of a future.\nAssert that an async call is a “simple” one. Simple is …\nStruct to store the state relevant to checking all futures …\nThe current program name.\nEmits a type checker error.\nEmits a type checker warning\nReturns the argument unchanged.\nThe error handler.\nCalls <code>U::from(self)</code>.\nReturns a new static analyzer given a symbol table and …\nWhether or not a non-async external call has been seen in …\nThe symbol table for the program.\nThe type table for the program.\nThe variant of the function that we are currently …\nEnter scope for <code>then</code> branch of conditional.\nWhether or not to do full tree search for await checking.\nExit scope for conditional statement at current depth.\nExit scope for <code>then</code> branch of conditional.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMaximum nesting depth to search for await checking.\nInitializes a new <code>AwaitChecker</code>.\nRemove from list. Returns <code>true</code> if there was a path where …\nInitialize futures.\nStatically updated set of futures to await.\nAll possible subsets of futures that must be awaited.\nA struct used to construct (unique) assignment statements.\nConsumes an access expression, accumulating any statements …\nConsumes an array expression, accumulating any statements …\nConsumes the expressions in an <code>AssertStatement</code>, returning …\nConsume all <code>AssignStatement</code>s, renaming as necessary.\nConsumes a binary expression, accumulating any statements …\nConsumes a <code>Block</code>, flattening its constituent …\nConsumes a call expression without visiting the function …\nConsumes a cast expression, accumulating any statements …\nConsumes a <code>ConditionalStatement</code>, producing phi functions …\nParsing guarantees that console statements are not present …\nConsumes the <code>DefinitionStatement</code> into an <code>AssignStatement</code>, …\nConsumes the expressions associated with …\nReconstructs the <code>Function</code>s in the <code>Program</code>, while …\nProduces a new <code>Identifier</code> with a unique name.\nConsumes and returns the literal without making any …\nConsumes and returns the locator expression without making …\nReconstructs the expression associated with the return …\nReconstructs records in the program, ordering its fields …\nConsumes a struct initialization expression with renamed …\nConsumes a ternary expression, accumulating any statements …\nConsumes a tuple expression, accumulating any statements …\nConsumes a unary expression, accumulating any statements …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA flag to determine whether or not the traversal is on the …\nInitializes a new <code>StaticSingleAssigner</code> with an empty …\nA counter used to generate unique node IDs.\nIf the RenameTable has a parent, then <code>self.rename_table</code> is …\nThe main program name.\nPushes a new scope, setting the current scope as the new …\nThe <code>RenameTable</code> for the current basic block in the AST\nThe <code>SymbolTable</code> of the program.\nA mapping from node IDs to their types.\nConstructs a simple assign statement for <code>expr</code> with a …\nA compiler pass during which the <code>SymbolTable</code> is created. …\nRuns the compiler pass.\nReturns the argument unchanged.\nThe error handler.\nCalls <code>U::from(self)</code>.\nWhether or not traversing stub.\nThe current program name.\nThe set of local structs that have been successfully …\nThe <code>SymbolTable</code> constructed by this compiler pass.\nEmits an error to the error handler if the given type is …\nUse this method when you know the actual type. Emits an …\nEmits an error if the type is not an array.\nEmits an error to the handler if the given type is not a …\nEmits an error to the handler if the given type is not a …\nEmits an error to the handler if the given type is not a …\nEmits an error to the handler if the given type is not a …\nEmits an error to the handler if the given type is not a …\nEmits an error to the handler if the given type is not a …\nEmits an error to the handler if the given type is not a …\nEmits an error to the handler if the given type is not a …\nEmits an error to the handler if the given type is not a …\nEmits an error to the handler if the given type is not a …\nEmits an error to the handler if the given type is not a …\nEmits an error to the handler if the given type is not an …\nEmits an error to the handler if the given type is not a …\nEmits an error if the type is not a mapping.\nEmits an error if the struct member is a record type.\nEmits an error to the handler if the given type is not a …\nEmits an error to the handler if the given type is not a …\nEmits an error to the handler if the given type is not a …\nEmits an error to the error handler if the <code>actual</code> type is …\nEmits an error if the type or its constituent types is not …\nEmits an error to the handler if the given type is not an …\nMapping from async function name to the inferred input …\nThe call graph for the program.\nType checks the inputs to a core function call and returns …\nEmits an error if the two given types are not equal.\nReturns the <code>struct</code> type and emits an error if the <code>expected</code> …\nHelper function to check that the input and output of …\nEmits an error to the handler if the given type is invalid.\nCreates a new child scope.\nEmits a type checker error.\nEmits a type checker warning\nEnters a child scope.\nExits the current scope.\nReturns the argument unchanged.\nType checks the inputs to an associated constant and …\nEmits an error if the <code>struct</code> is not a core library struct. …\nThe error handler.\nInserts variable to symbol table.\nCalls <code>U::from(self)</code>.\nWrapper around lookup_struct that additionally records all …\nReturns a new type checker given a symbol table and error …\nThe state of the current scope being traversed.\nA dependency graph of the structs in program.\nThe symbol table for the program.\nA mapping from node IDs to their types.\nThe set of used composites.\nLocation of most recent external call that produced a …\nReturns the argument unchanged.\nThe name of the function that we are currently traversing.\nThe futures that must be propagated to an async function.\nWhether the finalize caller has called the finalize …\nWhether or not the function that we are currently …\nInitialize state variables for new function.\nCalls <code>U::from(self)</code>.\nWhether the current function is a call.\nWhether currently traversing a conditional statement.\nWhether or not we are currently traversing a return …\nWhether or not we are currently traversing a stub.\nGet the current location.\nInitializes a new <code>ScopeState</code>.\nCurrent program name.\nThe variant of the function that we are currently …")